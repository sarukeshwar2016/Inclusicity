
================================================================================
FILE: .\dump.py
================================================================================

import os

def dump_python_files(project_dir, output_file="project_dump.txt"):
    exclude_dirs = {"venv", "__pycache__", ".git", "node_modules"}

    with open(output_file, "w", encoding="utf-8") as out:
        for root, dirs, files in os.walk(project_dir):

            # Filter unwanted folders
            dirs[:] = [d for d in dirs if d not in exclude_dirs]

            for filename in files:
                if filename.endswith(".py"):
                    file_path = os.path.join(root, filename)

                    out.write("\n" + "=" * 80 + "\n")
                    out.write(f"FILE: {file_path}\n")
                    out.write("=" * 80 + "\n\n")

                    try:
                        with open(file_path, "r", encoding="utf-8") as f:
                            out.write(f.read())
                    except Exception as e:
                        out.write(f"[ERROR READING FILE] {e}")

                    out.write("\n\n")

    print(f"Dump completed! Saved as: {output_file}")



# IMPORTANT: Call the function here
if __name__ == "__main__":
    dump_python_files(project_dir=".")



================================================================================
FILE: .\backend\app.py
================================================================================

from flask import Flask
from flask_pymongo import PyMongo
from dotenv import load_dotenv
import os

load_dotenv()

app = Flask(__name__)

# ✅ JWT CONFIG (MUST be inside app.config)
app.config["JWT_SECRET_KEY"] = os.getenv(
    "JWT_SECRET_KEY",
    "super-secret-key-change-this"
)
app.config["JWT_ALGORITHM"] = "HS256"
app.config["JWT_EXPIRY_HOURS"] = 24

# MongoDB
app.config["MONGO_URI"] = os.getenv("MONGO_URI")
mongo = PyMongo(app)

# Register Blueprints
from routes.auth import auth_bp
app.register_blueprint(auth_bp, url_prefix="/auth")

from routes.requests import requests_bp
app.register_blueprint(requests_bp, url_prefix="/requests")

from routes.admin import admin_bp
app.register_blueprint(admin_bp, url_prefix="/admin")


@app.route('/')
def home():
    return "Flask is connected to MongoDB!"

if __name__ == '__main__':
    app.run(debug=True)



================================================================================
FILE: .\backend\run.py
================================================================================




================================================================================
FILE: .\backend\routes\admin.py
================================================================================

from flask import Blueprint, jsonify, current_app
from bson import ObjectId
from datetime import datetime

from routes.auth import jwt_required, role_required

admin_bp = Blueprint("admin", __name__)


# =========================================================
# DB helper
# =========================================================
def get_db():
    pymongo_ext = current_app.extensions.get("pymongo")
    if pymongo_ext:
        return pymongo_ext.db
    from app import mongo
    return mongo.db


# =========================================================
# 1️⃣ VIEW ALL UNVERIFIED HELPERS
# =========================================================
@admin_bp.route("/helpers/pending", methods=["GET"])
@jwt_required
@role_required("admin")
def pending_helpers():
    db = get_db()

    helpers = db.helpers.find({"verified": False})

    result = []
    for h in helpers:
        result.append({
            "helper_id": str(h["_id"]),
            "name": h["name"],
            "email": h["email"],
            "city": h["city"],
            "skills": h["skills"],
            "ngo_id": h["ngo_id"],
            "created_at": h["created_at"]
        })

    return jsonify({"pending_helpers": result}), 200


# =========================================================
# 2️⃣ VERIFY HELPER
# =========================================================
@admin_bp.route("/helpers/<helper_id>/verify", methods=["PATCH"])
@jwt_required
@role_required("admin")
def verify_helper_admin(helper_id):
    db = get_db()

    helper = db.helpers.find_one({"_id": ObjectId(helper_id)})
    if not helper:
        return jsonify({"error": "Helper not found"}), 404

    if helper.get("verified"):
        return jsonify({"message": "Helper already verified"}), 200

    db.helpers.update_one(
        {"_id": helper["_id"]},
        {"$set": {"verified": True}}
    )

    return jsonify({"message": "Helper verified successfully"}), 200


# =========================================================
# 3️⃣ PLATFORM STATS (DASHBOARD)
# =========================================================
@admin_bp.route("/stats", methods=["GET"])
@jwt_required
@role_required("admin")
def platform_stats():
    db = get_db()

    stats = {
        "total_users": db.users.count_documents({}),
        "total_helpers": db.helpers.count_documents({}),
        "verified_helpers": db.helpers.count_documents({"verified": True}),
        "pending_helpers": db.helpers.count_documents({"verified": False}),
        "total_requests": db.requests.count_documents({}),
        "completed_requests": db.requests.count_documents({"status": "completed"}),
        "active_requests": db.requests.count_documents({"status": "accepted"})
    }

    return jsonify({"stats": stats}), 200



================================================================================
FILE: .\backend\routes\auth.py
================================================================================

import jwt
from functools import wraps
from flask import Blueprint, request, jsonify, current_app
from werkzeug.security import generate_password_hash, check_password_hash
from datetime import datetime, timedelta
from bson import ObjectId

auth_bp = Blueprint("auth", __name__)

# =========================================================
# DB helper
# =========================================================
def get_db():
    pymongo_ext = current_app.extensions.get("pymongo")
    if pymongo_ext:
        return pymongo_ext.db
    from app import mongo
    return mongo.db


# =========================================================
# JWT helpers
# =========================================================
def generate_jwt(payload):
    payload["exp"] = datetime.utcnow() + timedelta(
        hours=current_app.config["JWT_EXPIRY_HOURS"]
    )
    return jwt.encode(
        payload,
        current_app.config["JWT_SECRET_KEY"],
        algorithm=current_app.config["JWT_ALGORITHM"]
    )


def decode_jwt(token):
    return jwt.decode(
        token,
        current_app.config["JWT_SECRET_KEY"],
        algorithms=[current_app.config["JWT_ALGORITHM"]]
    )


def jwt_required(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        auth_header = request.headers.get("Authorization")

        if not auth_header:
            return jsonify({"error": "Authorization token missing"}), 401

        try:
            token = auth_header.split(" ")[1]  # Bearer <token>
            request.user = decode_jwt(token)
        except jwt.ExpiredSignatureError:
            return jsonify({"error": "Token expired"}), 401
        except jwt.InvalidTokenError:
            return jsonify({"error": "Invalid token"}), 401

        return f(*args, **kwargs)
    return wrapper


def role_required(required_role):
    def decorator(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            user = getattr(request, "user", None)

            if not user:
                return jsonify({"error": "Unauthorized"}), 401

            if user.get("role") != required_role:
                return jsonify({
                    "error": f"Access denied. {required_role} only."
                }), 403

            return f(*args, **kwargs)
        return wrapper
    return decorator


# =========================================================
# USER SIGNUP
# =========================================================
@auth_bp.route("/signup", methods=["POST"])
def signup_user():
    db = get_db()
    data = request.get_json() or {}

    required = ["name", "email", "password", "age"]
    if any(k not in data for k in required):
        return jsonify({"error": "Missing required fields"}), 400

    email = data["email"].strip().lower()

    if db.users.find_one({"email": email}) or db.helpers.find_one({"email": email}):
        return jsonify({"error": "Email already exists"}), 409

    try:
        age = int(data["age"])
    except ValueError:
        return jsonify({"error": "Age must be a number"}), 400

    user = {
        "name": data["name"],
        "email": email,
        "password": generate_password_hash(data["password"]),
        "age": age,
        "city": data.get("city"),
        "phone": data.get("phone"),
        "mobility_needs": data.get("mobility_needs"),
        "role": "user",
        "created_at": datetime.utcnow()
    }

    db.users.insert_one(user)
    return jsonify({"message": "User registered successfully"}), 201


# =========================================================
# HELPER SIGNUP
# =========================================================
@auth_bp.route("/signup/helper", methods=["POST"])
def signup_helper():
    db = get_db()
    data = request.get_json() or {}

    required = ["name", "email", "password", "age", "city", "phone", "ngo_id", "skills"]
    if any(k not in data for k in required):
        return jsonify({"error": "Missing required fields"}), 400

    email = data["email"].strip().lower()

    if db.users.find_one({"email": email}) or db.helpers.find_one({"email": email}):
        return jsonify({"error": "Email already exists"}), 409

    try:
        age = int(data["age"])
        if age < 18:
            return jsonify({"error": "Helper must be 18 or older"}), 400
    except ValueError:
        return jsonify({"error": "Invalid age"}), 400

    if not isinstance(data["skills"], list) or not data["skills"]:
        return jsonify({"error": "Skills must be a non-empty list"}), 400

    ngo = db.ngos.find_one({"_id": data["ngo_id"]})
    if not ngo:
        return jsonify({"error": "Invalid NGO"}), 400

    helper = {
        "name": data["name"],
        "email": email,
        "password": generate_password_hash(data["password"]),
        "age": age,
        "city": data["city"],
        "phone": data["phone"],
        "skills": data["skills"],
        "ngo_id": data["ngo_id"],
        "experience": data.get("experience"),
        "gender": data.get("gender"),
        "verified": False,
        "available": True,
        "role": "helper",
        "created_at": datetime.utcnow()
    }

    db.helpers.insert_one(helper)
    return jsonify({"message": "Helper application submitted"}), 201


# =========================================================
# LOGIN (USER + HELPER)
# =========================================================
@auth_bp.route("/login", methods=["POST"])
def login():
    db = get_db()
    data = request.get_json() or {}

    email = data.get("email", "").strip().lower()
    password = data.get("password", "")

    if not email or not password:
        return jsonify({"error": "Email and password required"}), 400

    account = db.users.find_one({"email": email})

    if account:
        role = account.get("role", "user")
    else:
        account = db.helpers.find_one({"email": email})
        role = "helper"


    if not account or not check_password_hash(account["password"], password):
        return jsonify({"error": "Invalid credentials"}), 401

    if role == "helper" and not account.get("verified"):
        return jsonify({"error": "Helper not verified"}), 403

    token = generate_jwt({
        "user_id": str(account["_id"]),
        "email": email,
        "role": role
    })

    return jsonify({
        "message": "Login successful",
        "token": token,
        "role": role
    }), 200

# =========================================================
# HELPER AVAILABILITY TOGGLE
# =========================================================
@auth_bp.route("/helper/availability", methods=["PATCH"])
@jwt_required
@role_required("helper")
def toggle_availability():
    db = get_db()
    data = request.get_json() or {}

    if "available" not in data:
        return jsonify({"error": "Availability field required"}), 400

    if not isinstance(data["available"], bool):
        return jsonify({"error": "Availability must be true or false"}), 400

    helper_id = ObjectId(request.user["user_id"])

    db.helpers.update_one(
        {"_id": helper_id},
        {"$set": {"available": data["available"]}}
    )

    return jsonify({
        "message": "Availability updated",
        "available": data["available"]
    }), 200


# =========================================================
# VERIFY HELPER (ADMIN / NGO)
# =========================================================
@auth_bp.route("/helpers/<identifier>/verify", methods=["PATCH"])
def verify_helper(identifier):
    db = get_db()

    helper = db.helpers.find_one({"email": identifier})
    if not helper:
        try:
            helper = db.helpers.find_one({"_id": ObjectId(identifier)})
        except:
            return jsonify({"error": "Helper not found"}), 404

    db.helpers.update_one(
        {"_id": helper["_id"]},
        {"$set": {"verified": True}}
    )

    return jsonify({"message": "Helper verified"}), 200


# =========================================================
# PROTECTED ROUTES
# =========================================================

# Any logged-in user
@auth_bp.route("/me", methods=["GET"])
@jwt_required
def me():
    return jsonify({
        "message": "Access granted",
        "user": request.user
    }), 200


# USER-only route
@auth_bp.route("/user/dashboard", methods=["GET"])
@jwt_required
@role_required("user")
def user_dashboard():
    return jsonify({
        "message": "Welcome USER",
        "user": request.user
    }), 200


# HELPER-only route
@auth_bp.route("/helper/dashboard", methods=["GET"])
@jwt_required
@role_required("helper")
def helper_dashboard():
    return jsonify({
        "message": "Welcome HELPER",
        "user": request.user
    }), 200



================================================================================
FILE: .\backend\routes\requests.py
================================================================================

from flask import Blueprint, request, jsonify, current_app
from datetime import datetime
from bson import ObjectId
from functools import wraps

# Import decorators from auth
from routes.auth import jwt_required, role_required

requests_bp = Blueprint("requests", __name__)


# =========================================================
# DB helper
# =========================================================
def get_db():
    pymongo_ext = current_app.extensions.get("pymongo")
    if pymongo_ext:
        return pymongo_ext.db
    from app import mongo
    return mongo.db


# =========================================================
# 1️⃣ USER CREATES A REQUEST (QUERY)
# =========================================================
@requests_bp.route("", methods=["POST"])
@jwt_required
@role_required("user")
def create_request():
    db = get_db()
    data = request.get_json() or {}

    required = ["city", "need"]
    if any(k not in data for k in required):
        return jsonify({"error": "Missing required fields"}), 400

    new_request = {
        "user_id": ObjectId(request.user["user_id"]),
        "city": data["city"],
        "need": data["need"],
        "status": "pending",          # pending | accepted | completed | cancelled
        "helper_id": None,
        "created_at": datetime.utcnow()
    }

    result = db.requests.insert_one(new_request)

    return jsonify({
        "message": "Request created successfully",
        "request_id": str(result.inserted_id)
    }), 201


# =========================================================
# 2️⃣ HELPER VIEWS AVAILABLE REQUESTS (CITY-BASED)
# =========================================================
@requests_bp.route("/available", methods=["GET"])
@jwt_required
@role_required("helper")
def view_available_requests():
    db = get_db()

    helper = db.helpers.find_one({
        "_id": ObjectId(request.user["user_id"])
    })

    if not helper or not helper.get("available"):
        return jsonify({"error": "Helper not available"}), 403

    requests_cursor = db.requests.find({
        "city": helper["city"],
        "status": "pending"
    })

    results = []
    for r in requests_cursor:
        results.append({
            "request_id": str(r["_id"]),
            "city": r["city"],
            "need": r["need"],
            "created_at": r["created_at"]
        })

    return jsonify({
        "available_requests": results
    }), 200


# =========================================================
# 3️⃣ HELPER ACCEPTS A REQUEST
# =========================================================
@requests_bp.route("/<request_id>/accept", methods=["PATCH"])
@jwt_required
@role_required("helper")
def accept_request(request_id):
    db = get_db()

    helper_id = ObjectId(request.user["user_id"])

    helper = db.helpers.find_one({"_id": helper_id})
    if not helper or not helper.get("available"):
        return jsonify({"error": "Helper not available"}), 403

    req = db.requests.find_one({
        "_id": ObjectId(request_id),
        "status": "pending"
    })

    if not req:
        return jsonify({"error": "Request not found or already taken"}), 404

    db.requests.update_one(
        {"_id": req["_id"]},
        {
            "$set": {
                "status": "accepted",
                "helper_id": helper_id,
                "accepted_at": datetime.utcnow()
            }
        }
    )

    # Optional: mark helper unavailable
    db.helpers.update_one(
        {"_id": helper_id},
        {"$set": {"available": False}}
    )

    return jsonify({"message": "Request accepted"}), 200


# =========================================================
# 4️⃣ VIEW MY REQUESTS (USER / HELPER)
# =========================================================
@requests_bp.route("/my", methods=["GET"])
@jwt_required
def my_requests():
    db = get_db()
    role = request.user["role"]
    user_id = ObjectId(request.user["user_id"])

    if role == "user":
        cursor = db.requests.find({"user_id": user_id})
    else:
        cursor = db.requests.find({"helper_id": user_id})

    results = []
    for r in cursor:
        results.append({
            "request_id": str(r["_id"]),
            "city": r["city"],
            "need": r["need"],
            "status": r["status"],
            "created_at": r["created_at"]
        })

    return jsonify({"requests": results}), 200
# =========================================================
# 5️⃣ HELPER COMPLETES A REQUEST
# =========================================================
@requests_bp.route("/<request_id>/complete", methods=["PATCH"])
@jwt_required
@role_required("helper")
def complete_request(request_id):
    db = get_db()

    helper_id = ObjectId(request.user["user_id"])

    req = db.requests.find_one({
        "_id": ObjectId(request_id),
        "helper_id": helper_id,
        "status": "accepted"
    })

    if not req:
        return jsonify({
            "error": "Request not found or not assigned to you"
        }), 404

    # Mark request as completed
    db.requests.update_one(
        {"_id": req["_id"]},
        {
            "$set": {
                "status": "completed",
                "completed_at": datetime.utcnow()
            }
        }
    )

    # Make helper available again
    db.helpers.update_one(
        {"_id": helper_id},
        {"$set": {"available": True}}
    )

    return jsonify({
        "message": "Request completed successfully"
    }), 200



================================================================================
FILE: .\backend\routes\__init__.py
================================================================================



